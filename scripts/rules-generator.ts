import { writeFileSync } from 'node:fs';
import path from 'node:path';
import { getLatestVersionFromClonedRepo } from './oxlint-version.js';
import { TARGET_DIRECTORY, VERSION_PREFIX } from './constants.js';
import type { Rule } from './traverse-rules.js';
import prettier from 'prettier';

const __dirname = new URL('.', import.meta.url).pathname;

export enum RulesGrouping {
  CATEGORY = 'category',
  SCOPE = 'scope',
}

export type ResultMap = Map<string, string[]>;

export class RulesGenerator {
  private rulesGrouping: RulesGrouping;
  private rulesArray: Rule[];
  constructor(
    rulesArray: Rule[] = [],
    rulesGrouping: RulesGrouping = RulesGrouping.SCOPE
  ) {
    this.rulesGrouping = rulesGrouping;
    this.rulesArray = rulesArray;
  }

  public setRulesGrouping(rulesGrouping: RulesGrouping) {
    this.rulesGrouping = rulesGrouping;
  }

  private groupItemsBy(
    rules: Rule[],
    rulesGrouping: RulesGrouping
  ): Map<string, string[]> {
    const map = new Map<string, string[]>();
    for (const item of rules) {
      const key = item[rulesGrouping];
      const group = map.get(key) || [];
      group.push(item.value);
      map.set(key, group);
    }

    return map;
  }

  public async generateRulesCode() {
    const oxlintVersion = getLatestVersionFromClonedRepo(
      TARGET_DIRECTORY,
      VERSION_PREFIX
    );

    if (!oxlintVersion) {
      throw new Error(
        'Failed to get the latest version of oxlint, did you forget to run `pnpm clone`?'
      );
    }

    console.log(
      `Generating rules for ${oxlintVersion}, grouped by ${this.rulesGrouping}`
    );

    const rulesGrouping = this.rulesGrouping;
    const rulesArray = this.rulesArray;

    const rulesMap = this.groupItemsBy(rulesArray, rulesGrouping);

    const exportGrouping: string[] = [];
    let code =
      '// These rules are automatically generated by scripts/generate-rules.ts\n\n';

    for (const grouping of rulesMap.keys()) {
      exportGrouping.push(grouping);
      const rules = rulesMap.get(grouping);

      code += `const ${grouping.replace(/_(\w)/g, (_, c) =>
        c.toUpperCase()
      )}Rules = {\n`;

      code += rules
        ?.map((rule) => {
          return `  '${rule.replace(/_/g, '-')}': "off"`;
        })
        .join(',\n');
      code += '\n}\n\n';
    }

    code += 'export {\n';
    code += exportGrouping
      .map((grouping) => {
        return `  ${grouping.replace(/_(\w)/g, (_, c) => c.toUpperCase())}Rules`;
      })
      .join(',\n');
    code += '\n}';

    const prettierConfig = await prettier.resolveConfig('.', {
      config: path.resolve(__dirname, '..', 'prettier.config.js'),
    });

    return await prettier.format(code, {
      ...prettierConfig,
      parser: 'typescript',
    });
  }

  public async generateRules() {
    const output = await this.generateRulesCode();
    writeFileSync(
      path.resolve(__dirname, '..', `src/rules-by-${this.rulesGrouping}.ts`),
      output
    );
  }
}
